<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Timer example</title>
    <link rel="stylesheet" href="//brick.a.ssl.fastly.net/Roboto:400,700,900/Open+Sans:400,700,900/Raleway:100,400,500,700,800,900">
    <link rel="stylesheet" href="../bundle.css">
    <script src="../bundle.js"></script>
  </head>
  <body>
    <div class="wrapper">
      <h2 id="a-dynamic-component">A Dynamic Component</h2>
      <p>We did the choice with vomit to not introduce any kind of state in your component. Creating a component is a simple as a function call. Updating a component should be the same.</p>
      <div class="vomit-snippet"><div class="column"><pre><code class="lang-js">function component(start) {
      var timer = vomit(function(seconds) {
        return vomit`&lt;div&gt;Seconds Elapsed: ${seconds}&lt;/div&gt;`
      })
      setInterval(() =&gt; timer(++start), 1000)
      return timer(start)
      }
      </code></pre>
      </div><div class="column"><script>
      (function() {
      function component(start) {
      var timer = vomit(function(seconds) {
        return vomit`<div>Seconds Elapsed: ${seconds}</div>`
      })
      setInterval(() => timer(++start), 1000)
      return timer(start)
      }
      document.currentScript.parentElement.appendChild(component(0))
      })()</script></div></div><p>When a component (aka function) is passed to vomit, vomit returns a function that takes data as input and return a DOM element. What&#39;s special about this function is that it always return the same element and updates it whenever the data passed change.</p>
      <p>Since component logic is written in JavaScript instead of templates, you can easily pass rich data through your app and predict what&#39;s gonna be displayed. Vomit components are functions, nothing more and for this simple reason building complex UIs by encapsulating components has never been so easy.</p>

    </div>
  </body>
</html>
